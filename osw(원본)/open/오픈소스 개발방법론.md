# 오픈소스 개발방법론

## 개발방법론의 등장배경

소프트웨어를 개발한다는 것은 정신적인 노가다의 연속이라고 볼 수 있다. 표면적으로는 아주 간단해보인다. 클라이언트\(고객\)의 요구에 맞는 구동되는 소프트웨어 코드를 짜서 팔면 된다. 요점은 잘 작동되는 코드라는 점이다. 알다시피 소프트웨어는 형체가 없다. 형체가 없는 존재를 정의하고 만든다는 것이 어렵다는 것은 불보듯 뻔한 일이다. 게다가 일의 진행상황도 알기 어렵다. 코드가 완성되기 전까지는 어디까지나 완전히 작동되지 않는 상태이기 때문이다.

예를 들어 케이크를 만드는 과정을 보면 밀가루 반죽 - 케이크 빵 틀에 반죽과 과일 넣기 - 오븐에 굽기 - 식히기 - 표면에 생크림과 장식하기의 순으로 이루어 진다. 여기서 반죽을 만드는 과정까지 했다면 진행의 초기단계, 오븐에 굽는 단계라면 중간단계임을 손쉽게 알 수 있다. 다만든 다음에 문제가 발견되서 처음부터 다시 해야하는 경우는 드물다. 왜냐하면 각단계에서 문제가 생긴다면 결과물이 있으니 알 수 있기 때문에 그 단계에서 고칠 수 있기 때문이다. 가령 밀가루가 상했다면 반죽단계에서 알 수 있기에 시정하면 되고 빵이 탔다면 굽는 온도가 높았으니 온도를 조절한 뒤 처음부터 다시 하면 된다. 다 완성해서야 문제를 알게되는 경우는 없다고 봐도 무방하다.

그러나 프로그램 개발은 그렇지 않다. 간단한 문법오류라면 개발과정에서 디버깅을 통해 고칠 수 있다. 일부의 논리 오류는 모듈화를 통해 프로그램을 나누어 실행해서 오류를 찾을 수 있다. 하지만 당연히 이걸로는 부족하다. 결국 중요한 문제들은 프로그램 전체를 가동해봐야 나타나기 마련이고 만약 중대한 문제가 발생 혹은 발견될 경우 처음부터 다시 해야할 수도 있다. 심지어 고객에게 프로그램이 전달된 후에 문제가 발견되기도 한다.\(비일비재하다. 그래서 유지보수를 한다.\) 아래의 리포트에서 볼 수 있듯이 소프트웨어 개발에서 32%만이 정해진 개발기간을 지켰다.

[https://galorath.com/blog/2009-standish-chaos-report-software-going-downhill/](https://galorath.com/blog/2009-standish-chaos-report-software-going-downhill/)

문제는 여기서 그치지 않는다. 오류를 고치고 하는데 시간만 드는 것이 아니기 때문이다. 프로그램 개발의 노동력은 당연히 공짜가 아니기에 시간이 늘어난다면 개발비용도 당연히 증가한다. 자본주의 사회에서 투자비용이 늘어난다는 것은 그만큼 이윤이 감소하는 리스크가 늘어난다는 뜻이고 이만큼 매리트 경우는 없을 것이다. 당연히 문제가 된다. 게다가 시스템이 커지기 시각하면서 이 문제는 더욱 도드라 졌다. 하드웨어는 '무어의 법칙'\(마이크로 칩의 밀도가 2년에 2배씩 늘어난다는 법칙\)을 착실하게 이행에 이행해 가며 성능은 높이고 가격은 낮춰가고 있던 반면에 이런 하드웨어를 돌려야할 소프트웨어는  아이러니하게 점차 할 일이 많아지면서 개발비용과 시간도 덩달아 상승한 것이다.\(이를 흔히 'software crisis', 소프트웨어 위기라고 하는데 시스템의 대규모화에 따라 개발비 증가, 계획 지현, 신뢰성 저하로 개발 수행이 매우 곤란해짐을 뜻한다. 1968년 NATO 소프트웨어 컨퍼런스에서 처음 쓰였다.\)

여기서 개발방법론이 등장한다. 소프트웨어 개발방법론은 이런 막막함을 조금이라도 해결해보려는 의도에서 자연스럽게 만들어졌다. 만드는 과정의 틀이 어느정도 주어지면 개발과정에서의 문제들을 쉽게 발견하고 해결해 나갈 수 있지 않을까하는 것이다. 개발방법론이 대두되기 시작한 시기는 1980년으로 점차 시스템이 비대해져가면서 전체 컴퓨터 가격에서 소프트웨어의 가격이 20%이던 1955년과 달리 80%에 달하던 때이다.

여기에 더해 소프트웨어 개발문제를 해결하는데 있어 이를 하나의 학문으로 연구하려는 움직임도 있었다. 이 분야는 '소프트웨어 공학'이라는 새로운 분야로 자리잡아갔는데 다른 공학분야의 문제해결 방식을 프로그래밍에 대입해보는 방식이었다.

