## 오픈소스 개발방법론

오래 기다렸다. 이제 오픈소스 개발방법론을 알아보자. 오픈소스 개발방법론은 말 그대로 개발에 오픈소스를 활용하는 것이다. 좀 더 쉽게 말하자면 오픈소스를 이용해서 애자일방식으로 개발하는 모델을 일컫는다. **크레이그 먼디**는 성당과 시장\(cathedral and bazarr\)에서 오픈소스 개발방법론에 대한 철학적인 바탕을 제시한다. 기존의 폭포수, 나선형같은 독점 소프트웨어 개발방법론은 성당을 짓는 것처럼 위계적이고 폐쇄적이기에 개발의 시간과 비용이 증가할 수 밖에 없다. 그러나 애자일과 오픈소스를 플럼빙\(plumbing\)하여 작성하는 코드개발은 시장처럼 시끌벅적하다. 논의가 오가고 많은 사람들이 협력하기에 비용과 시간은 줄어들 수 밖에 없다.

그렇다면 오픈소스는 개발과정 중 언제 들여와야 하는가? 당연히 개발 초기에 오픈소스를 들여다 보아야한다. 개발 초기에는 요구사항이 불명확해서 매우 많은 시간을 소비하는 경우가 많다. 이 때에 오픈소스 커뮤니티들에서 오픈소스를 들여다보면 이미 필요한 기능이 개발된 경우가 많고 라이센스를 확인해서 들여오기만 하면된다. 게다가 오픈소스는 이미 많은 개발자들에 의해 사용된 검증된 소스이기에 버그도 적다. 당연히 추후 테스팅 과정에서의 비용과 시간도 줄어든다.

여기서 드는 의문은 그렇다면 오픈소스만 가져오고 개발 과정은 폐쇄적으로 할 수 있지 않느냐는 점이다. 물론 그렇수 있다. 그러나 그것은 오픈소스 개발 방법으로 보지는 않는다. 왜냐하면 원시소스만 가져와서 개발팀에서 수정, 업그레이드 하는 경우 커뮤니티가 아닌 본인들이 관리해야 하게되고 비용과 시간을 아끼려고 선택한 방법의 장점은 사라지게 되기 때문이다. 즉, 소스코드는 재사용할 수 있는 것으로 보아야하고 본래의 코드에 기여하는 방식으로 성장 변화시켜 사용하는 것이 극히 효율적이다라고 볼 수 있다.

또한 '성장'에 초점을 맞춘 애자일과 오픈소스의 '성장'은 일맥상통하기에 잘 맞기도 하기 때문이다. 가령 클라이언트가 빨리 목적지에 도착하는 수단을 요구했을 때 애자일 방식의 개발은 처음에는 킥보드를 개발해서 주고 다음에는 자전거를 그리고 더 개발을 진행시킨다음에는 오토바이를, 마지막에는 자동차를 준다. 오픈소스도 마찬가지로 처음에는 불완전하지만 작동하는 형태에 많은 이들의 협업을 통해 점차 어른으로 성장해가는 과정을 거친다. 개발방식에서도 오픈소스 자체를 만드는 커뮤니티처럼 수평적 조직을 운영해야하는 이유가 여기에 있다.

### VCS

이를 위해 오픈소스 개발에서는 특정한** VCS\(버전 컨트롤 시스템\)**을 운용한다. 오픈소스 개발방법론에서는 아주 잦은 코드의 변경, 수정이 이루어지기 때문에 이를 보조할 VCS는 필수적이다.\(인간이 다 관리하는 것은 불가능에 가깝다.\) VCS는 코드의 모든 변화들을 추적한다. 언제 새로운 코드가 추가됬는지, 삭제됬는지, 누가 했는지, 어떤것이 변화했는지, 코드가 증가했는지 줄었는지 등등의 것을 전부다 말이다.

초기의 VCS는 중앙에 서버를 둔 집중식이었다. Subversion이라는 프로그램이 많이 쓰였는데 느리고 비효율적이었다. 이것이 bit keeper같은 협업식으로 바뀌었다가 git이 개발되면서 대부분 git을 오픈소스 개발의 VCS로 삼았다.

| 주로 쓰인 VCS들을 시대순으로 나열 |
| :---: |


| **CVS** | Current vesions systems, 동시버전 관리시스템으로도 알려져 있다. 모든 작업과 모든 변화를 추적하고 개발자들이 협력할 수 있게 한다. 다만 파일 단위 입출력, 디렉토리의 이동이나 이름의 변경 불가, 거의 동시에 코드 변경시 오류를 발생시키는 등의 문제를 갖고 있었다. |
| :--- | :--- |
| **SubVersion** | 오픈소스에서도 쓰이지만 기업에서도 많이 쓰이는 방식이다. 중앙집중식이며 CVS와 달리 다른 사용자와 엉키지 않고 파일의 이름을 바꿀 수 있었다. 그리고 전체적으로 CVS에 비해 빨라졌다. |
| **Bitkeeper** | Fork와 merge같은 작업이 subversion에 비해 비약적으로 속도가 상승하였으나 기업에서 개발한 제품으로 사용에 많은 제약이 걸려 최종적으로는 거의 사용되지 않았다. |
| **Arch,Darcs,Monotones** | Bitkeeper가 사용중단되고 한동안 오픈소스개발자들이 임의로 개발하여 쓰였다. git이 개발되기 전까지의 기간에 잠깐 쓰인 VCS들이다. |
| **Git** | Bitkeeper의 모든 장점에 모든 단점을 없엔 거의 궁극적인 VCS가 되었다. 현재 전세계에서 가장 많이 쓰이는 VCS이다. |

일반적인 VCS들의 기능은 다음과 같다.

1. **저장소\(repository\) :** 코드가 공유되고 저장되는 장소이다. 누구나 코드를 다운로드할 수 있고 허가된 개발자들은 코드를 수정할 수 있는 권한을 가진다.
2. **체크아웃 :** 개별 개발자들이 코드의 카피를 자기고 IDE와 연결하는 행위
3. **푸쉬\(push\)** **:** 수정한 코드를 저장소로 보내는 행위
4. **커밋\(commit\) :** 개별 저장소에 코드를 저장하는 행위로 허가된 개발자들은 직접 소스코드에 commit하기도 한다.
5. **머지\(merge\) :** 두 코드 조각을 합치는 행위
6. **패치\(patch\) :** 원시코드에 코드가 추가되는 것, 누가 기여했는지도 알린다.
7. **브랜치\(branch\)** **:** 분리되고 독립적으로 개발가능한 카피, 코딩 후에는 master branch에 merge시킨다.

### 개발 과정

오픈소스 개발방법론에 따른 개발 과정은 다음과 같다.

1. 클라이언트의 요구사항 접수
2. 오픈소스 활용 검토
3. 설계,개발
4. 테스팅
5. 프로그램 출고

설계, 개발 과정에서 바로 위의 VCS를 적절히 사용하는 것이다. 오픈소스를 활용한다는 전제하에 설계 개발에는 다양한 오픈소스들이 쓰인다. 오픈소스가 쓰이지 않는 부분은 도메인 클래스를 만들 때인데 도메인 클래스는 개인 정보 같은 민감한 정보가 들어가기 때문이다. 클라이언트가 원하는 정보와 입력은 모두 여기에 들어간다. 그리고 데이터베이스 개발에는 오픈소스인 MySQL같은 소스들을 활용할 수 있다. 개발된 코드는 공개되어 다시 다른 개발자의 코딩에 쓰이게 되는 **선순환 구조**를 갖는다. 오픈소스를 코딩에 적용하는 방식은 아래의 경우가 있다.

* 블랙박스 재사용 : 이 경우에는 원래의 소프트웨어를 거의 원본 그대로 사용한다. 이 방식의 장점은 구매비용과 구입시 발생하는 로열티를 아낄 수 있으며 공급업체에 종속되어 그 업체 제품만을 사야하는 지경에 이르는 것을 막을 수 있다. 
* 그레이 박스 재사용 : 코드를 고치는 것은 유저 인터페이스 같은 부가적인 부분에서만 하고 대부분을 고치지 않는다. 그렇다 할지라도 기존 오픈소스에 대해 심도있는 이해가 있어야 할 수 있기에 초기에는 상당한 시간, 금액이 들어간다.
* 화이트 박스 재사용 : 오픈소스의 내부 동작 과정을 연구한 뒤 쓰임에 맞게 개조, 수정하여 사용한다. 거의 대부분을 고처서 쓰는 재사용 과정이다. 유명한 예시로 구글이 리눅스 커널을 가져다 고쳐쓰는 것을 들 수 있다.

또한 재사용될 코드를 선택하는데 있어 아래의 **기준**을 두고 엄격히 점검해야한다.

* 신뢰성,성숙도
* 유지보수성
* 기존 기술과의 호환여부
* 확장성과 이식성
* 클라이언트의 요구사항에 충족하는가
* 보안성
* 인터페이스의 유연성
* 다른 운영체제 및 하드웨어에서의 동작여부
* 라이선스의 적법성

### 의의

오픈소스 개발방법론은 소프트웨어 산업에서 중요한 의미를 갖는다. 소프트웨어 개발은 시간도 오래걸리고 어렵고 힘들어서 많은 개발자들이 떠날 정도 였다.\(사실 지금도 그렇다\) 그러나 오픈소스를 사용함으로써 코드는 재사용, 재가공되고 많은 비용과 시간을 줄일 수 있게되었다.**we are better than me**가 오픈소스 개발의 기치이다. 백지장도 맞들면 낫다는 속담을 증명하는 것만 같은 분야이다.

